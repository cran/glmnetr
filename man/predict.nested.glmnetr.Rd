% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/summary.nested.glmnetr_230218.R
\name{predict.nested.glmnetr}
\alias{predict.nested.glmnetr}
\title{Give predicteds based upon the cv.glmnet output object contained in the nested.glmnetr output object.}
\usage{
\method{predict}{nested.glmnetr}(object, xs_new = NULL, lam = NULL, gam = NULL, comment = TRUE, ...)
}
\arguments{
\item{object}{A nested.glmnetr output object.}

\item{xs_new}{The predictor matrix.  If NULL, then betas are provided.}

\item{lam}{The lambda value for choice of beta.  If NULL, then 
lambda.min is used from the cross validation informed relaxed model.  We
use the term lam instead of lambda as lambda usually denotes a vector 
in the package.}

\item{gam}{The gamma value for choice of beta.  If NULL, then 
gamma.min is used from the cross validation informed relaxed model.  We
use the term gam instead of gamma as gamma usually denotes a vector 
in the package.}

\item{comment}{Default of TRUE to write to console information on lam and gam selected for output.
FALSE will suppress this write to console.}

\item{...}{Additional arguments passed to the predict function.}
}
\value{
Either the xs_new*Beta estimates based upon the predictor matrix, 
or model coefficients.
}
\description{
This is essentially a redirect to the summary.cv.glmnetr
function for nested.glmnetr output objects, based uopn the cv.glmnetr
output object contained in the nested.glmnetr output object.
}
\examples{
\donttest{
sim.data=glmnetr.simdata(nrows=1000, ncols=100, beta=NULL)
xs=sim.data$xs 
y_=sim.data$yt
event=sim.data$event
# for this example we use a small number for folds_n to shorten run time 
fit3 = nested.glmnetr(xs, NULL, y_, event, family="cox", folds_n=3) 
betas = predict(fit3)
betas$beta
}

}
\seealso{
\code{\link{predict.cv.glmnetr}}
}

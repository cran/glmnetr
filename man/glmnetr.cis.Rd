% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/glmnetr_CIs_240410.R
\name{glmnetr.cis}
\alias{glmnetr.cis}
\title{Calculate performance measure CI's and p's}
\usage{
glmnetr.cis(object, type = "devrat", pow = 1, digits = 4, returnd = 0)
}
\arguments{
\item{object}{A nested.glmnetr output object.}

\item{type}{determines what type of nested cross validation performance measures are 
compared.  Possible values are "devrat" to compare the deviance ratios, i.e. the 
fractional reduction in deviance relative to the null model deviance, 
"agree" to compare agreement, "lincal" to compare the linear calibration 
slope coefficients, "intcal" to compare the linear calibration intercept 
coefficients, from the nested cross validation.}

\item{pow}{the power to which the average of correlations is to be raised.  Only 
applies to the "gaussian" model.  Default is 2 to yield R-square but can be on to 
show correlations.  pow is ignored for the family of "cox" and "binomial".  When
pow = 2, calculations are made using correlations and the final estimates and 
confidence intervals are raised to the power of 2.  A negative sign before an 
R-square estimate or confidence limit indicates the estimate or confidence 
limit was negative before being raised to the power of 2.}

\item{digits}{digits for printing of z-scores, p-values, etc. with default of 4}

\item{returnd}{1 to return the deviance ratios in a list, 0 to not return.  The
deviances are stored in the nested.glmnetr() output object but not the deviance
ratios.  This function provides a simple mechanism to obtain the cross validated
deviance ratios.}
}
\value{
A printout to the R console
}
\description{
Calculate overall estimates and confidence intervals for performance measures
based upon stored cross validation performance measures in a nested.glmnetr()
output object.
}
\examples{
\donttest{
sim.data=glmnetr.simdata(nrows=1000, ncols=100, beta=NULL)
xs=sim.data$xs 
y_=sim.data$yt
event=sim.data$event
# for this example we use a small number for folds_n to shorten run time 
fit3 = nested.glmnetr(xs, NULL, y_, event, family="cox", folds_n=3) 
glmnetr.cis(fit3)
}

}
\seealso{
\code{\link{glmnetr.compcv}} , \code{\link{summary.nested.glmnetr}} , \code{\link{nested.glmnetr}}
}
